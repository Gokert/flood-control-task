# Что нужно сделать

Реализовать интерфейс с методом для проверки правил флуд-контроля. Если за последние N секунд вызовов метода Check будет больше K, значит, проверка на флуд-контроль не пройдена.

- Интерфейс FloodControl располагается в файле main.go.

- Флуд-контроль может быть запущен на нескольких экземплярах приложения одновременно, поэтому нужно предусмотреть общее хранилище данных. Допустимо использовать любое на ваше усмотрение. 

# Необязательно, но было бы круто

Хорошо, если добавите поддержку конфигурации итоговой реализации. Параметры — на ваше усмотрение.

# Описание реализации

### Хранилище

Потенциально вызовов метода Check может быть много, поэтому нужно обеспечить быстрый доступ к данным.
Также мы не привязаны к какой-то определенной схеме имеющейся базы данных и потому остановился на Redis.

### Конфигурация

Для конфигурации определил следующие параметры, которые используются в реализации:

- FLOOD_TIME_DIF_MIL: N миллисекунд, которое будет храниться в кэше вызов (в миллисекундах).
- FLOOD_MAX_REQUEST: K максимальное количество вызов, которое будет на отрезке N.
- FLOOD_COUNT_REQUEST: количество вызовов функции Check за всё время.
- FLOOD_TIME_SLEEP_MIL: интервал между вызовами функции Check (в миллисекундах).

Конфигурационные данные лежат в Dockerfile.

### Реализация интерфейса FloodControl

В listen.go происходят вызовы функции Check() с интервалом FLOOD_TIME_SLEEP_MIL. Количество вызовов самой функции определяется значением переменной среды FLOOD_COUNT_REQUEST.

Далее в core.go лежит сама реализация метода Check() интерфейса FloodControl. Сначала идёт проверка сколько на данный момент вызовов за последнее N время, далее, если оно больше К, то возвращаем ошибку, иначе устанавливаем в БД новое значение. 

Ниже находится repo.go, где реализуется работа с БД. В самом файле определены два метода: Set и Get. Одно устанавливает ключ по userId и времени (например 51:message:1711376430), а другое получает по userId все существующие данные. В БД все данные хранятся не дольше FLOOD_TIME_DIF_MIL.

# Запуск окружения с приложением и Redis
```
docker-compose up
```
   
